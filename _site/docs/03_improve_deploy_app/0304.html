<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>4. Build, Push, and Deploy Changes</title>
  </head>
  <body>
    <nav>
  <a href="/">Home</a>
  <a href="/docs">Docs</a>
</nav>
    <h1 id="task-04---build-push-and-deploy-changes-40-minutes">Task 04 - Build, Push, and Deploy Changes (40 minutes)</h1>

<h2 id="introduction">Introduction</h2>

<p>With our Azure resources created, we have laid out the foundation for our application. Now, we must connect our source code with its destination. The first step in this journey is called Continuous Integration (CI).</p>

<p>Continuous Integration is the process of merging local code changes into source control and may include steps to automatically build and test the code. Effective Continuous Integration allows developers rapidly to iterate and collaborate. It also helps ensure that newly added code does not break the current application.</p>

<p>Review the following articles:</p>

<ul>
  <li><a href="https://docs.github.com/en/actions/building-and-testing-code-with-continuous-integration/about-continuous-integration">About continuous integration</a></li>
  <li><a href="https://docs.github.com/en/actions/building-and-testing-code-with-continuous-integration/setting-up-continuous-integration-using-github-actions">Setting up continuous integration using workflow templates</a></li>
</ul>

<p>The next practical step is to extend our workflow with steps to build a Docker image and push it to Azure Container Registry (ACR). After that, we will configure the Web App to pull this image from ACR.</p>

<p>Containers are a great way to package and deploy applications consistently across environments. If you are new to containers, there are 3 key steps to creating and publishing an image, which we will cover below. Because this training focuses on DevOps and not containers, we’ve strived to make this task as straightforward as possible.</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">docker login</code> - You need to log into the container registry into which you will push your image. These generally require authentication from an authorized user, as that will prevent unauthorized individuals from publishing images in your registry.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">docker build</code> - The second step is to request that Docker (running locally on your machine or on your build server) create the container image. A <em>critical</em> component of this is the <code class="language-plaintext highlighter-rouge">Dockerfile</code>, which gives instructions to Docker on how to build the image, files to copy, ports to expose, and startup commands.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">docker push</code> - Once you have created your Docker image, you need to store it in a container registry. Container registries are secure, centralized locations to store Docker images. Docker supports a <code class="language-plaintext highlighter-rouge">push</code> command that copies the Docker image to the registry in the repository you specify. A repository is a logical way of grouping and versioning Docker images, and Docker repositories do not necessarily need to match the structure of your GitHub repositories.</p>
  </li>
</ol>

<p>After we automate the build process, we also want to automate the release process. This is a technique called Continuous Delivery (CD). Please take a moment to review this brief article talking about why Continuous Delivery is important.</p>

<ul>
  <li><a href="https://docs.microsoft.com/en-us/azure/devops/learn/what-is-continuous-delivery">What is Continuous Delivery?</a></li>
</ul>

<h2 id="description">Description</h2>

<p>The team at Munson’s Pickles and Preserves would like to see how to implement Continuous Integration and Continuous Delivery (CI/CD) in the context of using Docker containers to build code and GitHub Actions workflows to deploy that code.</p>

<ol>
  <li>Create a new GitHub Actions <code class="language-plaintext highlighter-rouge">.NET</code> workflow. You should be able to find this in the “Continuous integration workflows” section.</li>
  <li>Review the workflow contents. Then, under the “Setup .NET Core” step, ensure that the .NET version is <code class="language-plaintext highlighter-rouge">6.0.x</code> in order to match the version defined in the Team Messaging System.</li>
  <li>Ensure that the workflow is configured to trigger on both pushes and pull requests, and then configure both of these triggers with path triggers which only act on changes in the <code class="language-plaintext highlighter-rouge">/Application</code> folder.</li>
  <li>Update each of the three pre-defined GitHub Actions workflow steps used to build the .NET application. For each of the three steps, you will need to update each command to pass the relative path to the appropriate <code class="language-plaintext highlighter-rouge">.csproj</code> file as an argument. The three steps are <code class="language-plaintext highlighter-rouge">restore</code>, <code class="language-plaintext highlighter-rouge">build</code>, and <code class="language-plaintext highlighter-rouge">test</code>. For <code class="language-plaintext highlighter-rouge">restore</code> and <code class="language-plaintext highlighter-rouge">build</code>, the argument you will pass in is the path to the application csproj file. For <code class="language-plaintext highlighter-rouge">test</code>, the argument you will pass in is the path to the unit test csproj file.</li>
  <li>Test the workflow by making a small change to application code, such as adding a comment to a file. Commit and push the change, and then ensure that the workflow completes successfully. At this point, any changes pushed to the <code class="language-plaintext highlighter-rouge">/Application</code> folder will automatically trigger the workflow–this is Continuous Integration in action.</li>
  <li>At the top of your workflow file, create 4 environment variables:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">registryName</code> - the full server address of your ACR instance. Set this to “<code class="language-plaintext highlighter-rouge">registryName</code>.azurecr.io”, replacing <code class="language-plaintext highlighter-rouge">registryName</code> with the <code class="language-plaintext highlighter-rouge">&lt;prefix&gt;devopsreg</code> value in your ARM template file on line #26.</li>
      <li><code class="language-plaintext highlighter-rouge">repositoryName</code> - The repository to target in the registry. Set this to “<code class="language-plaintext highlighter-rouge">techboost/dotnetcoreapp</code>”.</li>
      <li><code class="language-plaintext highlighter-rouge">dockerFolderPath</code> - The path to the folder that contains the Dockerfile. You will need to point to the folder <code class="language-plaintext highlighter-rouge">Application/src/RazorPagesTestSample</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">tag</code> - This needs to be a unique value each time, as this is used to version the images in the repository. GitHub makes <a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/context-and-expression-syntax-for-github-actions#github-context">environment variables</a> available to help with this. Set <code class="language-plaintext highlighter-rouge">tag</code> to the <a href="https://www.bing.com/search?q=%24%7B%7Bgithub.run_number%7D%7D&amp;form=QBLH&amp;sp=-1&amp;pq=%24%7B%7Bgithub.run_number%7D%7D&amp;sc=0-22&amp;qs=n&amp;sk=&amp;cvid=D84DA66323DC4E14BD794F90FCFD90D3">github.run_number</a> environment variable.</li>
    </ul>
  </li>
  <li>Go to the Azure Portal and get the username, password, and login server for your ACR instance and save these three as GitHub secrets. The names for these secrets should be <code class="language-plaintext highlighter-rouge">ACR_USERNAME</code>, <code class="language-plaintext highlighter-rouge">ACR_PASSWORD</code>, and <code class="language-plaintext highlighter-rouge">ACR_LOGIN_SERVER</code>, respectively.</li>
  <li>Add a second <strong>job</strong> to your existing .NET Core workflow. Make sure the first step in your second job includes <code class="language-plaintext highlighter-rouge">- uses: actions/checkout@v2</code>.</li>
  <li>To authenticate to the registry, add a step named <code class="language-plaintext highlighter-rouge">Docker login</code> with the following as the <code class="language-plaintext highlighter-rouge">run</code> command: <code class="language-plaintext highlighter-rouge">docker login $registryName -u ACR_USERNAME -p ACR_PASSWORD</code>. Be sure to use the GitHub secrets for ACR username and ACR password instead of the string literals “ACR_USERNAME” and “ACR_PASSWORD”.</li>
  <li>To build your image, add a step named <code class="language-plaintext highlighter-rouge">Docker build</code> with the following as the <code class="language-plaintext highlighter-rouge">run</code> command: <code class="language-plaintext highlighter-rouge">docker build -t $registryName/$repositoryName:$tag --build-arg build_version=$tag $dockerFolderPath</code></li>
  <li>To push your image to ACR, add a step named <code class="language-plaintext highlighter-rouge">Docker push</code> with the following as the <code class="language-plaintext highlighter-rouge">run</code> command: <code class="language-plaintext highlighter-rouge">docker push $registryName/$repositoryName:$tag</code></li>
  <li>Test the workflow by adding a comment to one of the application files. Commit, push, monitor the workflow. Verify that the GitHub Actions workflow builds a new container image, tags that image, and pushes the image to ACR.</li>
  <li>Configure your <code class="language-plaintext highlighter-rouge">dev</code> environment to pull the latest container image from ACR.
   13.1 - Log into Azure using your service principal, if needed (<a href="https://docs.microsoft.com/en-us/azure/app-service/deploy-container-github-action?tabs=service-principal#tabpanel_CeZOj-G++Q-3_service-principal">hint</a>).
   13.2 - Use the <code class="language-plaintext highlighter-rouge">Azure/webapps-deploy@v2</code> <a href="https://github.com/Azure/webapps-deploy">action</a> to update the Web App to pull the latest image from ACR. Key parameters to configure include:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">app-name</code> - the name of the wep app instance to target</li>
      <li><code class="language-plaintext highlighter-rouge">images</code> - the path to the image you pushed to ACR</li>
    </ul>
  </li>
  <li>Make a small change to your application, such as adding a string of display text to <code class="language-plaintext highlighter-rouge">Pages/Index.cshtml</code> in the app. From there, commit and push the change. Then, monitor the workflow and see if the change shows up on the dev instance of the website.</li>
  <li>Configure your workflow to deploy to your <code class="language-plaintext highlighter-rouge">test</code> and <code class="language-plaintext highlighter-rouge">prod</code> environments. Ensure that each environment includes a manual approval step before deployment.</li>
</ol>

<h2 id="success-criteria">Success Criteria</h2>

<ul>
  <li>Any changes pushed to the <code class="language-plaintext highlighter-rouge">/Application</code> folder automatically trigger the workflow.</li>
  <li>.NET Core restore, build, and test steps complete successfully.</li>
  <li>Each successful workflow run builds a new container image with a unique tag. Each container image should be available in the Azure Container Registry after each successful workflow run.</li>
  <li>A small change to a file such as <code class="language-plaintext highlighter-rouge">Pages/Index.cshtml</code> automatically shows up on the website running in the <code class="language-plaintext highlighter-rouge">dev</code> environment, <code class="language-plaintext highlighter-rouge">&lt;prefix&gt;devops-dev</code>.azurewebsites.net.</li>
  <li>Manual approval is required to deploy to the <code class="language-plaintext highlighter-rouge">test</code> and <code class="language-plaintext highlighter-rouge">prod</code> environments.</li>
</ul>

<h2 id="learning-resources">Learning Resources</h2>

<ul>
  <li><a href="https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/introduction-to-github-actions">Introduction to GitHub Actions</a></li>
  <li><a href="https://github.com/actions/starter-workflows/blob/dacfd0a22a5a696b74a41f0b49c98ff41ef88427/ci/dotnet-core.yml">.NET Core Action to build and test</a></li>
  <li><a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpaths">Understanding workflow path filters</a></li>
  <li><a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet#dotnet-commands">dotnet commands</a></li>
  <li><a href="https://github.com/Azure/actions">GitHub Actions for Azure</a></li>
  <li><a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#env">Environment variables</a></li>
  <li><a href="https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/introduction-to-github-actions">Introduction to GitHub Actions</a></li>
  <li><a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpaths">Understanding workflow path filters</a></li>
  <li><a href="https://docs.microsoft.com/en-us/azure/container-registry/container-registry-authentication#admin-account">Authenticate with an Azure container registry</a></li>
  <li><a href="https://github.com/Azure/actions">GitHub Actions for Azure</a></li>
  <li><a href="https://docs.microsoft.com/en-us/azure/app-service/deploy-container-github-action?tabs=service-principal#tabpanel_CeZOj-G++Q-3_service-principal">Deploy a custom container to App Service using GitHub Actions</a></li>
  <li><a href="https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment">Using environments for deployment</a></li>
</ul>

<h2 id="advanced-challenges-optional">Advanced Challenges (optional)</h2>

<p>If the GitHub Actions workflow fails, GitHub sends an e-mail to the repository owner. Sometimes, however, you may wish to log the failure or even create a GitHub issue upon failure. Add a step to your workflow which creates a GitHub issue if there is a failure at any point in the workflow.</p>

  </body>
</html>